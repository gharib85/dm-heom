// This file is part of DM-HEOM (https://github.com/noma/dm-heom)
//
// Copyright (c) 2015-2019 Matthias Noack, Zuse Institute Berlin
//
// Licensed under the 3-clause BSD License, see accompanying LICENSE,
// CONTRIBUTORS.md, and README.md for further information.

#include "heom/thermal_state_search.hpp"

namespace heom {

const std::string thermal_state_search::embedded_ocl_source_ {
#include "thermal_state_search.cl.hpp"  // NOTE: generated by CMake
};
const std::string thermal_state_search::embedded_ocl_kernel_name_ { "thermal_state_search" };

thermal_state_search::thermal_state_search(ocl::helper& ocl, const std::string& source_header, const std::string& ocl_compile_options, const ocl::nd_range& range)
	: ocl::kernel_wrapper(ocl, embedded_ocl_source_, embedded_ocl_kernel_name_, source_header, ocl_compile_options, range)
{
}

thermal_state_search::thermal_state_search(ocl::helper& ocl, const boost::filesystem::path& thermal_state_search_file_name, const std::string& thermal_state_search_kernel_name, const std::string& source_header, const std::string& ocl_compile_options, const ocl::nd_range& range)
	: ocl::kernel_wrapper(ocl, thermal_state_search_file_name, thermal_state_search_kernel_name, source_header, ocl_compile_options, range)
{
}

void thermal_state_search::set_args(const instance& heom_instance, const complex_t epsilon, const complex_matrix_t& c, const complex_matrix_t& c_transposed, const complex_vector_t& eigenvalues)
{
	cl_int err = 0;

	// allocate OpenCL buffers
	d_mem_c_ = ocl_.create_buffer(CL_MEM_READ_ONLY, heom_instance.size_hamiltonian_byte(), nullptr);
	d_mem_c_transposed_ = ocl_.create_buffer(CL_MEM_READ_ONLY, heom_instance.size_hamiltonian_byte(), nullptr);
	const size_t size_eigenvalues_byte = heom_instance.states() * sizeof(complex_t);
	d_mem_eigenvalues_ = ocl_.create_buffer(CL_MEM_READ_ONLY, size_eigenvalues_byte, nullptr);
	d_mem_pf_same_sum_  = ocl_.create_buffer(CL_MEM_READ_ONLY, heom_instance.size_pf_same_sum_byte(), nullptr);

	// inititialise OpenCL buffers
	err = ocl_.queue().enqueueWriteBuffer(d_mem_c_, CL_TRUE, 0, heom_instance.size_hamiltonian_byte(), c.data(), NULL, NULL);
	ocl::error_handler(err, "clEnqueueWriteBuffer(d_mem_c_)");
	err = ocl_.queue().enqueueWriteBuffer(d_mem_c_transposed_, CL_TRUE, 0, heom_instance.size_hamiltonian_byte(), c_transposed.data(), NULL, NULL);
	ocl::error_handler(err, "clEnqueueWriteBuffer(d_mem_c_transposed_)");
	err = ocl_.queue().enqueueWriteBuffer(d_mem_eigenvalues_, CL_TRUE, 0, size_eigenvalues_byte, eigenvalues.data(), NULL, NULL);
	ocl::error_handler(err, "clEnqueueWriteBuffer(d_mem_eigenvalues_)");
	err = ocl_.queue().enqueueWriteBuffer(d_mem_pf_same_sum_, CL_TRUE, 0, heom_instance.size_pf_same_sum_byte(), heom_instance.pf_same_sum(), NULL, NULL);
	ocl::error_handler(err, "clEnqueueWriteBuffer(d_mem_pf_same_sum_)");

	// epsilon
	real_t epsilon_real = epsilon.real();
	real_t epsilon_imag = epsilon.imag();
	err = kernel_.setArg(2, epsilon_real);
	ocl::error_handler(err, "clSetKernelArg(2)");
	err = kernel_.setArg(3, epsilon_imag);
	ocl::error_handler(err, "clSetKernelArg(3)");

	// C matrix
	err = kernel_.setArg(4, d_mem_c_);
	ocl::error_handler(err, "clSetKernelArg(4)");
	err = kernel_.setArg(5, d_mem_c_transposed_);
	ocl::error_handler(err, "clSetKernelArg(5)");

	// eigenvalues
	err = kernel_.setArg(6, d_mem_eigenvalues_);
	ocl::error_handler(err, "clSetKernelArg(6)");

	// pf_same_sum
	err = kernel_.setArg(7, d_mem_pf_same_sum_);
	ocl::error_handler(err, "clSetKernelArg(7)");
}

void thermal_state_search::run(cl::Buffer& d_mem_src, cl::Buffer& d_mem_dst)
{
	cl_int err = 0;

	// set dynamic kernel arguments
	err = kernel_.setArg(0, d_mem_dst);
	ocl::error_handler(err, "clSetKernelArg(0)");
	err = kernel_.setArg(1, d_mem_src);
	ocl::error_handler(err, "clSetKernelArg(1)");

	// run and benchmark kernel
	run_kernel();
}

} // namespace heom
